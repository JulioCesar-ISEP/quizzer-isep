const e=[{id:1,question:"Qual instrução carrega um byte unsigned da memória?",code:`// Loads
lb rd, imm(rs1)  // signed byte
??? rd, imm(rs1)  // unsigned byte`,options:["lbu","lhu","lw","lh"],correct:0,explanation:"lbu rd, imm(rs1) carrega byte unsigned, estendendo com zeros.",theoryPoints:{title:"Acessos à Memória em RISC-V",content:"Instruções load/store para bytes, halfwords, words. Signed extend com msb, unsigned com zero.",keyPoints:["lb/lbu: byte signed/unsigned","lh/lhu: half signed/unsigned","lw: word (32 bits)","sb/sh/sw: stores"],examples:`lbu a0, 0(sp)  // carrega byte unsigned da pilha
sw a1, 4(sp)  // armazena word`},hints:["Diferença signed vs unsigned","Extensão zero para unsigned"]},{id:2,question:"O que é hierarquia de memória?",code:`// Hierarquia
Registradores > Cache > RAM > Disco`,options:["Estrutura para otimizar velocidade e custo","Método para criptografar dados","Forma de endereçar registradores","Modelo de execução de programas"],correct:0,explanation:"Hierarquia equilibra velocidade (registradores/cache) com capacidade/custo (RAM/disco).",theoryPoints:{title:"Hierarquia de Memória",content:"Níveis com trade-off velocidade/capacidade. Princípio de localidade guia design.",keyPoints:["Registradores: mais rápidos, poucos","Cache: SRAM rápida","RAM: principal, volátil","Disco: secundária, persistente"],examples:"Em RISC-V, lw acessa RAM via cache; otimizações exploram localidade temporal/espacial."},hints:["Por que diferentes tipos de memória?","Velocidade vs Capacidade"]}];export{e as level3Exercises};
